"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.TelescopeBuilder = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var t = _interopRequireWildcard(require("@babel/types"));

var _package = _interopRequireDefault(require("../package.json"));

var _generator = _interopRequireDefault(require("@babel/generator"));

var _protoParser = require("@osmonauts/proto-parser");

var _imports = require("./imports");

var _build = require("./build");

var _ast2 = require("@osmonauts/ast");

var _types2 = require("@osmonauts/types");

var _utils = require("./utils");

var _parse = require("./parse");

var _bundle = require("./bundle");

var _fs = require("fs");

var _path = require("path");

var _mkdirp = require("mkdirp");

var _deepmerge = _interopRequireDefault(require("deepmerge"));

var _case = require("case");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var version = process.env.NODE_ENV === 'test' ? 'latest' : _package["default"].version;

var TelescopeBuilder = /*#__PURE__*/function () {
  function TelescopeBuilder(_ref) {
    var protoDirs = _ref.protoDirs,
        outPath = _ref.outPath,
        store = _ref.store,
        options = _ref.options;
    (0, _classCallCheck2["default"])(this, TelescopeBuilder);
    (0, _defineProperty2["default"])(this, "store", void 0);
    (0, _defineProperty2["default"])(this, "protoDirs", void 0);
    (0, _defineProperty2["default"])(this, "outPath", void 0);
    (0, _defineProperty2["default"])(this, "options", void 0);
    (0, _defineProperty2["default"])(this, "contexts", []);
    this.protoDirs = protoDirs;
    this.outPath = outPath;
    this.options = (0, _deepmerge["default"])(_types2.defaultTelescopeOptions, options !== null && options !== void 0 ? options : {});
    this.store = store !== null && store !== void 0 ? store : new _protoParser.ProtoStore(protoDirs);
    this.store.traverseAll();
  }

  (0, _createClass2["default"])(TelescopeBuilder, [{
    key: "context",
    value: function context(ref) {
      var ctx = new _build.TelescopeParseContext(ref, this.store, this.options);
      this.contexts.push(ctx);
      return ctx;
    }
  }, {
    key: "build",
    value: function build() {
      var _this = this;

      var allFiles = []; // [x] get bundle of all packages

      var bundled = (0, _bundle.bundlePackages)(this.store);
      bundled.forEach(function (bundle) {
        // store bundleFile in filesToInclude
        var filesToInclude = [bundle.bundleFile]; // [x] search for all files that live in package

        var baseProtos = _this.store.getProtos().filter(function (ref) {
          return ref.proto["package"].split('.')[0] === bundle.base;
        }); // [x] write out all TS files for package


        var packageContexts = baseProtos.map(function (ref) {
          var context = _this.context(ref);

          (0, _parse.parse)(context);
          context.buildBase(); // build BASE file

          var importStmts = (0, _imports.buildAllImports)(context, null, context.ref.filename);
          var prog = [].concat(importStmts).concat(context.body);
          var filename = ref.filename.replace(/\.proto/, '.ts');
          var out = (0, _path.join)(_this.outPath, filename);
          (0, _mkdirp.sync)((0, _path.dirname)(out));

          if (context.body.length > 0) {
            var _ast = t.program(prog);

            var gen = (0, _generator["default"])(_ast);
            (0, _fs.writeFileSync)(out, gen.code);
          } else {
            (0, _fs.writeFileSync)(out, "export {}");
          }

          return context;
        }); // [x] find services w/mutations

        var mutationContexts = packageContexts.filter(function (context) {
          return context.mutations.length > 0;
        });
        var queryContexts = packageContexts.filter(function (context) {
          return context.queries.length > 0;
        }); // [x] write out one amino helper for all contexts w/mutations

        var aminoConverters = mutationContexts.map(function (c) {
          if (!_this.options.includeAminos) {
            return;
          }

          var localname = c.ref.filename.replace(/\.proto$/, '.amino.ts');
          var filename = (0, _path.resolve)((0, _path.join)(_this.outPath, localname)); // FRESH new context

          var ctx = new _build.TelescopeParseContext(c.ref, c.store, _this.options); // BEGIN PLUGIN CODE HERE

          var amino = new _ast2.AminoParseContext(c.ref, c.store, _this.options);

          if (bundle.base === 'osmosis') {
            amino.options = {
              aminoCasingFn: _case.camel
            };
          }

          ctx.amino = amino; // END PLUGIN CODE HERE
          // get mutations, services

          (0, _parse.parse)(ctx); // now let's amino...

          ctx.buildAminoInterfaces();
          ctx.buildAminoConverter();
          var serviceImports = (0, _imports.getDepsFromMutations)(ctx.mutations, localname); // build file
          // DONT RENAME THE REF! you'll need to make a new one!
          // OR ELSE LATER the other build will use this name!
          // ctx.ref.filename = filename;

          var imports = (0, _imports.buildAllImports)(ctx, serviceImports, localname);
          var prog = [].concat(imports).concat(ctx.body);
          var ast = t.program(prog);
          var content = (0, _generator["default"])(ast).code;
          (0, _mkdirp.sync)((0, _path.dirname)(filename));
          (0, _fs.writeFileSync)(filename, content); // add to bundle

          (0, _bundle.createFileBundle)(c.ref.proto["package"], localname, bundle.bundleFile, bundle.importPaths, bundle.bundleVariables);
          return {
            localname: localname,
            filename: filename
          };
        }).filter(Boolean); // [x] write out one registry helper for all contexts w/mutations

        var registries = mutationContexts.map(function (c) {
          if (!_this.options.includeAminos) {
            return;
          }

          var localname = c.ref.filename.replace(/\.proto$/, '.registry.ts');
          var filename = (0, _path.resolve)((0, _path.join)(_this.outPath, localname)); // FRESH new context

          var ctx = new _build.TelescopeParseContext(c.ref, c.store, _this.options); // get mutations, services

          (0, _parse.parse)(ctx);
          ctx.buildRegistry();
          ctx.buildRegistryLoader();
          ctx.buildHelperObject(); // SEE ABOVE - DONT RENAME THESE DIRECTLY
          // ctx.ref.filename = filename;

          var serviceImports = (0, _imports.getDepsFromMutations)(ctx.mutations, localname);
          var imports = (0, _imports.buildAllImports)(ctx, serviceImports, localname);
          var prog = [].concat(imports).concat(ctx.body);
          var ast = t.program(prog);
          var content = (0, _generator["default"])(ast).code;
          (0, _mkdirp.sync)((0, _path.dirname)(filename));
          (0, _fs.writeFileSync)(filename, content); // add to bundle

          (0, _bundle.createFileBundle)(c.ref.proto["package"], localname, bundle.bundleFile, bundle.importPaths, bundle.bundleVariables);
          return {
            localname: localname,
            filename: filename
          };
        }).filter(Boolean); // [x] write out one registry helper for all contexts w/mutations

        var lcdClients = queryContexts.map(function (c) {
          var _proto$Query;

          if (!_this.options.includeLCDClient) {
            return;
          }

          var localname = c.ref.filename.replace(/\.proto$/, '.lcd.ts');
          var filename = (0, _path.resolve)((0, _path.join)(_this.outPath, localname)); // FRESH new context

          var ctx = new _build.TelescopeParseContext(c.ref, c.store, _this.options); // get mutations, services

          (0, _parse.parse)(ctx);
          var proto = (0, _protoParser.getNestedProto)(c.ref.traversed); // hard-coding, for now, only Query service

          if (!(proto !== null && proto !== void 0 && proto.Query) || ((_proto$Query = proto.Query) === null || _proto$Query === void 0 ? void 0 : _proto$Query.type) !== 'Service') {
            return;
          }

          var lcdAst = (0, _ast2.makeLCDClient)(ctx.generic, proto.Query);

          if (!lcdAst) {
            return;
          }

          var serviceImports = (0, _imports.getDepsFromQueries)(ctx.queries, localname);
          var imports = (0, _imports.buildAllImports)(ctx, serviceImports, localname);
          var prog = [].concat(imports).concat(ctx.body).concat(lcdAst);
          var ast = t.program(prog);
          var content = (0, _generator["default"])(ast).code;
          (0, _mkdirp.sync)((0, _path.dirname)(filename));
          (0, _fs.writeFileSync)(filename, content); // add to bundle

          (0, _bundle.createFileBundle)(c.ref.proto["package"], localname, bundle.bundleFile, bundle.importPaths, bundle.bundleVariables);
          return {
            localname: localname,
            filename: filename
          };
        }).filter(Boolean); // [x] write out one client for each base package, referencing the last two steps

        if (registries.length) {
          var registryImports = [];
          var converterImports = [];
          var clientFile = (0, _path.join)("".concat(bundle.base), 'client.ts');
          filesToInclude.push(clientFile);
          var ctx = new _ast2.GenericParseContext(null, null, _this.options);
          var registryVariables = [];
          var converterVariables = [];
          registries.forEach(function (registry) {
            var rel = (0, _path.relative)((0, _path.dirname)(clientFile), registry.localname);
            if (!rel.startsWith('.')) rel = "./".concat(rel);
            var variable = (0, _utils.variableSlug)(registry.localname);
            registryVariables.push(variable);
            registryImports.push((0, _ast2.importNamespace)(variable, rel));
          });
          aminoConverters.forEach(function (converter) {
            var rel = (0, _path.relative)((0, _path.dirname)(clientFile), converter.localname);
            if (!rel.startsWith('.')) rel = "./".concat(rel);
            var variable = (0, _utils.variableSlug)(converter.localname);
            converterVariables.push(variable);
            converterImports.push((0, _ast2.importNamespace)(variable, rel));
          });
          var name = 'getSigning' + (0, _case.pascal)(bundle.base + 'Client');
          var clientBody = (0, _ast2.createClient)({
            context: ctx,
            name: name,
            registries: registryVariables,
            aminos: converterVariables
          });
          var cProg = [(0, _ast2.importStmt)(['OfflineSigner', 'GeneratedType', 'Registry'], '@cosmjs/proto-signing'), (0, _ast2.importStmt)(['defaultRegistryTypes', 'AminoTypes', 'SigningStargateClient'], '@cosmjs/stargate')].concat(registryImports).concat(converterImports).concat(clientBody);
          var cAst = t.program(cProg);
          var cContent = (0, _generator["default"])(cAst).code;
          var clientOutFile = (0, _path.join)(_this.outPath, clientFile);
          (0, _mkdirp.sync)((0, _path.dirname)(clientOutFile));
          (0, _fs.writeFileSync)(clientOutFile, cContent);
        } // [x] bundle


        var body = (0, _ast2.recursiveModuleBundle)(bundle.bundleVariables);
        var prog = [].concat(bundle.importPaths).concat(body);
        var ast = t.program(prog);
        var content = (0, _generator["default"])(ast).code;
        var out = (0, _path.resolve)((0, _path.join)(_this.outPath, bundle.bundleFile));
        (0, _mkdirp.sync)((0, _path.dirname)(out));
        (0, _fs.writeFileSync)(out, content); // [x] write an index file for each base
        // console.log(filesToInclude)

        filesToInclude.forEach(function (file) {
          return allFiles.push(file);
        });
      }); // finally, write one index file with all files, exported

      var indexFile = 'index.ts';
      var indexOutFile = (0, _path.join)(this.outPath, indexFile);
      var stmts = allFiles.map(function (file) {
        return t.exportAllDeclaration(t.stringLiteral((0, _utils.getRelativePath)(indexFile, file)));
      });
      var finalAst = t.program(stmts);
      var indexContent = (0, _generator["default"])(finalAst).code;
      (0, _mkdirp.sync)((0, _path.dirname)(indexOutFile));
      var header = "/**\n  * This file and any referenced files were automatically generated by ".concat(_package["default"].name, "@").concat(version, "\n  * DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain\n  * and run the transpile command or yarn proto command to regenerate this bundle.\n  */\n \n");
      (0, _fs.writeFileSync)(indexOutFile, header + indexContent);
    }
  }]);
  return TelescopeBuilder;
}();

exports.TelescopeBuilder = TelescopeBuilder;

var _default = function _default(input) {
  var builder = new TelescopeBuilder(input);
  builder.build();
};

exports["default"] = _default;