import * as t from '@babel/types'; // TODO move to @osmonauts/utils package

export const classMethod = (kind, key, params, body, returnType, leadingComments = [], computed = false, _static = false, generator = false, async = false) => {
  const obj = t.classMethod(kind, key, params, body, computed, _static, generator, async);

  if (returnType) {
    obj.returnType = returnType;
  }

  if (leadingComments) {
    obj.leadingComments = leadingComments;
  }

  return obj;
};
export const tsEnumMember = (id, initializer, leadingComments) => {
  const obj = t.tsEnumMember(id, initializer);
  obj.leadingComments = leadingComments;
  return obj;
};
export const tsPropertySignature = (key, typeAnnotation, optional) => {
  const obj = t.tsPropertySignature(key, typeAnnotation);
  obj.optional = optional;
  return obj;
};
export const functionDeclaration = (id, params, body, generator, async, returnType) => {
  const func = t.functionDeclaration(id, params, body, generator, async);
  func.returnType = returnType;
  return func;
};
export const callExpression = (callee, _arguments, typeParameters) => {
  const callExpr = t.callExpression(callee, _arguments);
  callExpr.typeParameters = typeParameters;
  return callExpr;
};
export const identifier = (name, typeAnnotation, optional = false) => {
  const type = t.identifier(name);
  type.typeAnnotation = typeAnnotation;
  type.optional = optional;
  return type;
};
export const classDeclaration = (name, body, implementsExressions = [], superClass = null) => {
  const declaration = t.classDeclaration(t.identifier(name), superClass, t.classBody(body));

  if (implementsExressions.length) {
    declaration.implements = implementsExressions;
  }

  return declaration;
};
export const classProperty = (name, typeAnnotation = null, isReadonly = false, isStatic = false) => {
  const prop = t.classProperty(t.identifier(name));
  if (isReadonly) prop.readonly = true;
  if (isStatic) prop.static = true;
  if (typeAnnotation) prop.typeAnnotation = typeAnnotation;
  return prop;
};
export const arrowFunctionExpression = (params, body, returnType, isAsync = false) => {
  const func = t.arrowFunctionExpression(params, body, isAsync);
  if (returnType) func.returnType = returnType;
  return func;
};
export const objectPattern = (properties, typeAnnotation) => {
  const obj = t.objectPattern(properties);
  obj.typeAnnotation = typeAnnotation;
  return obj;
};
export const objectMethod = (kind, key, params, body, computed, generator, async, returnType, typeParameters) => {
  const obj = t.objectMethod(kind, key, params, body, computed, generator, async);
  obj.returnType = returnType;
  obj.typeParameters = typeParameters;
  return obj;
};