"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.types = exports.getWireNumber = exports.getTagNumber = exports.getTSTypeFromProtoType = exports.getPackedWireNumber = exports.getOneOfs = exports.getObjectNameOld = exports.getKeyTypeEntryName = exports.getFieldsTypeName = exports.getFieldOptionality = exports.getEnumToJsonName = exports.getEnumFromJsonName = exports.getDefaultTSTypeFromProtoType = exports.getBaseCreateTypeFuncName = exports.createProtoType = exports.createCreateProtoType = exports.SCALAR_TYPES = exports.NATIVE_TYPES = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _case = require("case");

var _utils = require("../../utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var SCALAR_TYPES = ['string', 'double', 'float', 'int32', 'uint32', 'sint32', 'fixed32', 'sfixed32', 'int64', 'uint64', 'sint64', 'fixed64', 'sfixed64', 'bytes', 'bool'];
exports.SCALAR_TYPES = SCALAR_TYPES;
var NATIVE_TYPES = [].concat(SCALAR_TYPES, [// TODO move these out
'google.protobuf.Timestamp', 'google.protobuf.Duration', 'google.protobuf.Any']);
exports.NATIVE_TYPES = NATIVE_TYPES;

var getTSTypeFromProtoType = function getTSTypeFromProtoType(type) {
  switch (type) {
    case 'string':
      return t.tsStringKeyword();

    case 'double':
    case 'float':
    case 'int32':
    case 'uint32':
    case 'sint32':
    case 'fixed32':
    case 'sfixed32':
      return t.tsNumberKeyword();

    case 'int64':
    case 'uint64':
    case 'sint64':
    case 'fixed64':
    case 'sfixed64':
      return t.tsTypeReference(t.identifier('Long'));

    case 'bytes':
      return t.tsTypeReference(t.identifier('Uint8Array'));

    case 'bool':
      return t.tsBooleanKeyword();

    case 'google.protobuf.Timestamp':
      return t.tsTypeReference(t.identifier('Date'));

    case 'google.protobuf.Duration':
      return t.tsStringKeyword();

    case 'google.protobuf.Any':
      return t.tsTypeReference(t.identifier('Any'));

    default:
      throw new Error('getTSTypeFromProtoType() type not found');
  }

  ;
}; // https://github.com/protobufjs/protobuf.js/blob/master/src/types.js#L38-L54


exports.getTSTypeFromProtoType = getTSTypeFromProtoType;
var types = {
  basic: {
    "double": 1,
    "float": 5,
    int32: 0,
    uint32: 0,
    sint32: 0,
    fixed32: 5,
    sfixed32: 5,
    int64: 0,
    uint64: 0,
    sint64: 0,
    fixed64: 1,
    sfixed64: 1,
    bool: 0,
    string: 2,
    bytes: 2
  },
  defaults: {
    "double": 0,
    "float": 0,
    int32: 0,
    uint32: 0,
    sint32: 0,
    fixed32: 0,
    sfixed32: 0,
    int64: 0,
    uint64: 0,
    sint64: 0,
    fixed64: 0,
    sfixed64: 0,
    bool: false,
    string: '',
    bytes: [],
    undefined: null
  },
  "long": {
    int64: 0,
    uint64: 0,
    sint64: 0,
    fixed64: 1,
    sfixed64: 1
  },
  mapKey: {
    int32: 0,
    uint32: 0,
    sint32: 0,
    fixed32: 5,
    sfixed32: 5,
    int64: 0,
    uint64: 0,
    sint64: 0,
    fixed64: 1,
    sfixed64: 1,
    bool: 0,
    string: 2
  },
  packed: {
    "double": 1,
    "float": 5,
    int32: 0,
    uint32: 0,
    sint32: 0,
    fixed32: 5,
    sfixed32: 5,
    int64: 0,
    uint64: 0,
    sint64: 0,
    fixed64: 1,
    sfixed64: 1,
    bool: 0
  }
};
exports.types = types;

var getWireNumber = function getWireNumber(type) {
  if (types.basic.hasOwnProperty(type)) {
    return types.basic[type];
  }

  return 2;
};

exports.getWireNumber = getWireNumber;

var getPackedWireNumber = function getPackedWireNumber(type) {
  if (types.packed.hasOwnProperty(type)) {
    return types.packed[type];
  }

  return 2;
};

exports.getPackedWireNumber = getPackedWireNumber;

var getTagNumber = function getTagNumber(field) {
  var wire = getWireNumber(field.type);

  if (field.parsedType.type === 'Enum') {
    wire = 0;
  }

  if (field.rule === 'repeated') {
    wire = 2;
  }

  return (field.id << 3 | wire) >>> 0;
};

exports.getTagNumber = getTagNumber;

var getDefaultTSTypeFromProtoType = function getDefaultTSTypeFromProtoType(field, isOptional) {
  var _field$parsedType;

  if (isOptional) {
    return t.identifier('undefined');
  }

  if (field.rule === 'repeated') {
    return t.arrayExpression([]);
  }

  if (field.keyType) {
    return t.objectExpression([]);
  }

  if (((_field$parsedType = field.parsedType) === null || _field$parsedType === void 0 ? void 0 : _field$parsedType.type) === 'Enum') {
    return t.numericLiteral(0);
  }

  switch (field.type) {
    case 'string':
      return t.stringLiteral('');

    case 'double':
    case 'float':
    case 'int32':
    case 'uint32':
    case 'sint32':
    case 'fixed32':
    case 'sfixed32':
      return t.numericLiteral(0);

    case 'uint64':
      return t.memberExpression(t.identifier('Long'), t.identifier('UZERO'));

    case 'int64':
    case 'sint64':
    case 'fixed64':
    case 'sfixed64':
      return t.memberExpression(t.identifier('Long'), t.identifier('ZERO'));

    case 'bytes':
      return t.newExpression(t.identifier('Uint8Array'), []);

    case 'bool':
      return t.booleanLiteral(false);
    // OTHER TYPES

    case 'google.protobuf.Timestamp':
      return t.identifier('undefined');

    case 'google.protobuf.Duration':
      return t.identifier('undefined');

    case 'google.protobuf.Any':
      return t.identifier('undefined');

    case 'cosmos.base.v1beta1.Coins':
      return t.arrayExpression([]);

    case 'cosmos.base.v1beta1.Coin':
      return t.identifier('undefined');

    default:
      // console.warn('getDefaultTSTypeFromProtoType() type not found: ' + type);
      return t.identifier('undefined');
  }

  ;
};

exports.getDefaultTSTypeFromProtoType = getDefaultTSTypeFromProtoType;

var lowerFirst = function lowerFirst(str) {
  return str.charAt(0).toLowerCase() + str.substring(1);
};

var upperFirst = function upperFirst(str) {
  return str.charAt(0).toUpperCase() + str.substring(1);
};

var getEnumToJsonName = function getEnumToJsonName(name) {
  return lowerFirst(name) + 'ToJSON';
};

exports.getEnumToJsonName = getEnumToJsonName;

var getEnumFromJsonName = function getEnumFromJsonName(name) {
  return lowerFirst(name) + 'FromJSON';
};

exports.getEnumFromJsonName = getEnumFromJsonName;

var getFieldsTypeName = function getFieldsTypeName(field) {
  if ((field === null || field === void 0 ? void 0 : field.scope.length) <= 1) return field.parsedType.name;

  var _field$scope = (0, _toArray2["default"])(field.scope),
      _pkg = _field$scope[0],
      scopes = _field$scope.slice(1);

  return [].concat((0, _toConsumableArray2["default"])(scopes), [field.parsedType.name]).join('_');
};

exports.getFieldsTypeName = getFieldsTypeName;

var getKeyTypeEntryName = function getKeyTypeEntryName(typeName, prop) {
  return "".concat(typeName, "_").concat((0, _case.pascal)(prop), "Entry");
};

exports.getKeyTypeEntryName = getKeyTypeEntryName;

var getBaseCreateTypeFuncName = function getBaseCreateTypeFuncName(name) {
  return "createBase".concat(upperFirst(name));
};

exports.getBaseCreateTypeFuncName = getBaseCreateTypeFuncName;

var getOneOfs = function getOneOfs(type) {
  var _type$oneofs;

  var keys = Object.keys((_type$oneofs = type.oneofs) !== null && _type$oneofs !== void 0 ? _type$oneofs : {});
  if (!keys.length) return [];
  if (keys.length !== 1) throw new Error('getOneOfs() oneofs cardinality not known!');
  return type.oneofs[keys[0]].oneof;
};

exports.getOneOfs = getOneOfs;

var getFieldOptionality = function getFieldOptionality(field, isOneOf) {
  var _field$options;

  return isOneOf || (field === null || field === void 0 ? void 0 : (_field$options = field.options) === null || _field$options === void 0 ? void 0 : _field$options['(gogoproto.nullable)']);
};

exports.getFieldOptionality = getFieldOptionality;

var getObjectNameOld = function getObjectNameOld(name) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (!scope.length || scope.length === 1) return name;

  var _scope = (0, _toArray2["default"])(scope),
      _pkg = _scope[0],
      scopes = _scope.slice(1);

  return [].concat((0, _toConsumableArray2["default"])(scopes), [name]).join('_');
};

exports.getObjectNameOld = getObjectNameOld;

var getProtoFieldTypeName = function getProtoFieldTypeName(context, field) {
  var name = context.getTypeName(field);
  return (0, _utils.renderNameSafely)(name);
};

var getProtoField = function getProtoField(context, field) {
  var _field$options2;

  var ast = null;
  var optional = false;

  if ((_field$options2 = field.options) !== null && _field$options2 !== void 0 && _field$options2['(gogoproto.nullable)']) {
    optional = true;
  }

  if (NATIVE_TYPES.includes(field.type)) {
    ast = getTSTypeFromProtoType(field.type);
  } else {
    ast = t.tsTypeReference(t.identifier(getProtoFieldTypeName(context, field)));
  }

  if (field.rule === 'repeated') {
    ast = t.tsArrayType(ast);
  }

  if (field.keyType) {
    ast = t.tsUnionType([t.tsTypeLiteral([t.tsIndexSignature([(0, _utils.identifier)('key', t.tsTypeAnnotation(getTSTypeFromProtoType(field.keyType)))], t.tsTypeAnnotation(ast))])]);
  }

  return ast;
};

var createProtoType = function createProtoType(context, name, proto) {
  var _proto$options;

  var oneOfs = getOneOfs(proto);
  var declaration = t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(name), null, [], t.tsInterfaceBody(Object.keys(proto.fields).reduce(function (m, fieldName) {
    var _field$options3;

    var isOneOf = oneOfs.includes(fieldName);
    var field = proto.fields[fieldName];
    var propSig = (0, _utils.tsPropertySignature)(t.identifier(fieldName), t.tsTypeAnnotation(getProtoField(context, field)), getFieldOptionality(field, isOneOf));
    var comments = [];

    if (field.comment) {
      comments.push((0, _utils.commentBlock)(field.comment));
    }

    if ((_field$options3 = field.options) !== null && _field$options3 !== void 0 && _field$options3.deprecated) {
      comments.push((0, _utils.commentBlock)('@deprecated'));
    }

    if (comments.length) {
      propSig.leadingComments = comments;
    }

    m.push(propSig);
    return m;
  }, []))));
  var comments = [];

  if (proto.comment) {
    comments.push((0, _utils.commentBlock)(proto.comment));
  }

  if ((_proto$options = proto.options) !== null && _proto$options !== void 0 && _proto$options.deprecated) {
    comments.push((0, _utils.commentBlock)('@deprecated'));
  }

  if (comments.length) {
    declaration.leadingComments = comments;
  }

  return declaration;
};

exports.createProtoType = createProtoType;

var createCreateProtoType = function createCreateProtoType(name, proto) {
  var oneOfs = getOneOfs(proto);
  var fields = Object.keys(proto.fields).map(function (key) {
    var isOneOf = oneOfs.includes(key);
    var isOptional = getFieldOptionality(proto.fields[key], isOneOf);
    return _objectSpread(_objectSpread({
      name: key
    }, proto.fields[key]), {}, {
      isOptional: isOptional
    });
  }).map(function (field) {
    return t.objectProperty(t.identifier(field.name), getDefaultTSTypeFromProtoType(field, field.isOptional));
  });
  return (0, _utils.functionDeclaration)(t.identifier(getBaseCreateTypeFuncName(name)), [], t.blockStatement([t.returnStatement(t.objectExpression((0, _toConsumableArray2["default"])(fields)))]), false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(name))));
};

exports.createCreateProtoType = createCreateProtoType;