"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tsPropertySignature = exports.tsEnumMember = exports.objectPattern = exports.objectMethod = exports.identifier = exports.functionDeclaration = exports.classProperty = exports.classMethod = exports.classDeclaration = exports.callExpression = exports.arrowFunctionExpression = void 0;

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// TODO move to @osmonauts/utils package
var classMethod = function classMethod(kind, key, params, body, returnType) {
  var leadingComments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
  var computed = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

  var _static = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;

  var generator = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  var async = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
  var obj = t.classMethod(kind, key, params, body, computed, _static, generator, async);

  if (returnType) {
    obj.returnType = returnType;
  }

  if (leadingComments) {
    obj.leadingComments = leadingComments;
  }

  return obj;
};

exports.classMethod = classMethod;

var tsEnumMember = function tsEnumMember(id, initializer, leadingComments) {
  var obj = t.tsEnumMember(id, initializer);
  obj.leadingComments = leadingComments;
  return obj;
};

exports.tsEnumMember = tsEnumMember;

var tsPropertySignature = function tsPropertySignature(key, typeAnnotation, optional) {
  var obj = t.tsPropertySignature(key, typeAnnotation);
  obj.optional = optional;
  return obj;
};

exports.tsPropertySignature = tsPropertySignature;

var functionDeclaration = function functionDeclaration(id, params, body, generator, async, returnType) {
  var func = t.functionDeclaration(id, params, body, generator, async);
  func.returnType = returnType;
  return func;
};

exports.functionDeclaration = functionDeclaration;

var callExpression = function callExpression(callee, _arguments, typeParameters) {
  var callExpr = t.callExpression(callee, _arguments);
  callExpr.typeParameters = typeParameters;
  return callExpr;
};

exports.callExpression = callExpression;

var identifier = function identifier(name, typeAnnotation) {
  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var type = t.identifier(name);
  type.typeAnnotation = typeAnnotation;
  type.optional = optional;
  return type;
};

exports.identifier = identifier;

var classDeclaration = function classDeclaration(name, body) {
  var implementsExressions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var superClass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var declaration = t.classDeclaration(t.identifier(name), superClass, t.classBody(body));

  if (implementsExressions.length) {
    declaration["implements"] = implementsExressions;
  }

  return declaration;
};

exports.classDeclaration = classDeclaration;

var classProperty = function classProperty(name) {
  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var isReadonly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isStatic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var prop = t.classProperty(t.identifier(name));
  if (isReadonly) prop.readonly = true;
  if (isStatic) prop["static"] = true;
  if (typeAnnotation) prop.typeAnnotation = typeAnnotation;
  return prop;
};

exports.classProperty = classProperty;

var arrowFunctionExpression = function arrowFunctionExpression(params, body, returnType) {
  var isAsync = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var func = t.arrowFunctionExpression(params, body, isAsync);
  if (returnType) func.returnType = returnType;
  return func;
};

exports.arrowFunctionExpression = arrowFunctionExpression;

var objectPattern = function objectPattern(properties, typeAnnotation) {
  var obj = t.objectPattern(properties);
  obj.typeAnnotation = typeAnnotation;
  return obj;
};

exports.objectPattern = objectPattern;

var objectMethod = function objectMethod(kind, key, params, body, computed, generator, async, returnType, typeParameters) {
  var obj = t.objectMethod(kind, key, params, body, computed, generator, async);
  obj.returnType = returnType;
  obj.typeParameters = typeParameters;
  return obj;
};

exports.objectMethod = objectMethod;