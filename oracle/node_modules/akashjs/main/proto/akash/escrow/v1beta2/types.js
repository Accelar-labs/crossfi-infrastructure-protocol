"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FractionalPayment_State = exports.FractionalPayment = exports.Account_State = exports.AccountID = exports.Account = void 0;
exports.account_StateFromJSON = account_StateFromJSON;
exports.account_StateToJSON = account_StateToJSON;
exports.fractionalPayment_StateFromJSON = fractionalPayment_StateFromJSON;
exports.fractionalPayment_StateToJSON = fractionalPayment_StateToJSON;

var _coin = require("../../../cosmos/base/v1beta1/coin");

var _m0 = _interopRequireWildcard(require("protobufjs/minimal"));

var _helpers = require("@osmonauts/helpers");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/** State stores state for an escrow account */
var Account_State;
exports.Account_State = Account_State;

(function (Account_State) {
  Account_State[Account_State["invalid"] = 0] = "invalid";
  Account_State[Account_State["open"] = 1] = "open";
  Account_State[Account_State["closed"] = 2] = "closed";
  Account_State[Account_State["overdrawn"] = 3] = "overdrawn";
  Account_State[Account_State["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Account_State || (exports.Account_State = Account_State = {}));

function account_StateFromJSON(object) {
  switch (object) {
    case 0:
    case "invalid":
      return Account_State.invalid;

    case 1:
    case "open":
      return Account_State.open;

    case 2:
    case "closed":
      return Account_State.closed;

    case 3:
    case "overdrawn":
      return Account_State.overdrawn;

    case -1:
    case "UNRECOGNIZED":
    default:
      return Account_State.UNRECOGNIZED;
  }
}

function account_StateToJSON(object) {
  switch (object) {
    case Account_State.invalid:
      return "invalid";

    case Account_State.open:
      return "open";

    case Account_State.closed:
      return "closed";

    case Account_State.overdrawn:
      return "overdrawn";

    default:
      return "UNKNOWN";
  }
}
/** Payment State */


var FractionalPayment_State;
exports.FractionalPayment_State = FractionalPayment_State;

(function (FractionalPayment_State) {
  FractionalPayment_State[FractionalPayment_State["invalid"] = 0] = "invalid";
  FractionalPayment_State[FractionalPayment_State["open"] = 1] = "open";
  FractionalPayment_State[FractionalPayment_State["closed"] = 2] = "closed";
  FractionalPayment_State[FractionalPayment_State["overdrawn"] = 3] = "overdrawn";
  FractionalPayment_State[FractionalPayment_State["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FractionalPayment_State || (exports.FractionalPayment_State = FractionalPayment_State = {}));

function fractionalPayment_StateFromJSON(object) {
  switch (object) {
    case 0:
    case "invalid":
      return FractionalPayment_State.invalid;

    case 1:
    case "open":
      return FractionalPayment_State.open;

    case 2:
    case "closed":
      return FractionalPayment_State.closed;

    case 3:
    case "overdrawn":
      return FractionalPayment_State.overdrawn;

    case -1:
    case "UNRECOGNIZED":
    default:
      return FractionalPayment_State.UNRECOGNIZED;
  }
}

function fractionalPayment_StateToJSON(object) {
  switch (object) {
    case FractionalPayment_State.invalid:
      return "invalid";

    case FractionalPayment_State.open:
      return "open";

    case FractionalPayment_State.closed:
      return "closed";

    case FractionalPayment_State.overdrawn:
      return "overdrawn";

    default:
      return "UNKNOWN";
  }
}
/** AccountID is the account identifier */


function createBaseAccountID() {
  return {
    scope: "",
    xid: ""
  };
}

var AccountID = {
  encode: function encode(message) {
    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();

    if (message.scope !== "") {
      writer.uint32(10).string(message.scope);
    }

    if (message.xid !== "") {
      writer.uint32(18).string(message.xid);
    }

    return writer;
  },
  decode: function decode(input, length) {
    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    var end = length === undefined ? reader.len : reader.pos + length;
    var message = createBaseAccountID();

    while (reader.pos < end) {
      var tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.scope = reader.string();
          break;

        case 2:
          message.xid = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },
  fromJSON: function fromJSON(object) {
    return {
      scope: (0, _helpers.isSet)(object.scope) ? String(object.scope) : "",
      xid: (0, _helpers.isSet)(object.xid) ? String(object.xid) : ""
    };
  },
  toJSON: function toJSON(message) {
    var obj = {};
    message.scope !== undefined && (obj.scope = message.scope);
    message.xid !== undefined && (obj.xid = message.xid);
    return obj;
  },
  fromPartial: function fromPartial(object) {
    var _object$scope, _object$xid;

    var message = createBaseAccountID();
    message.scope = (_object$scope = object.scope) !== null && _object$scope !== void 0 ? _object$scope : "";
    message.xid = (_object$xid = object.xid) !== null && _object$xid !== void 0 ? _object$xid : "";
    return message;
  }
};
exports.AccountID = AccountID;

function createBaseAccount() {
  return {
    id: undefined,
    owner: "",
    state: 0,
    balance: undefined,
    transferred: undefined,
    settledAt: _helpers.Long.ZERO,
    depositor: "",
    funds: undefined
  };
}

var Account = {
  encode: function encode(message) {
    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();

    if (message.id !== undefined) {
      AccountID.encode(message.id, writer.uint32(10).fork()).ldelim();
    }

    if (message.owner !== "") {
      writer.uint32(18).string(message.owner);
    }

    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }

    if (message.balance !== undefined) {
      _coin.DecCoin.encode(message.balance, writer.uint32(34).fork()).ldelim();
    }

    if (message.transferred !== undefined) {
      _coin.DecCoin.encode(message.transferred, writer.uint32(42).fork()).ldelim();
    }

    if (!message.settledAt.isZero()) {
      writer.uint32(48).int64(message.settledAt);
    }

    if (message.depositor !== "") {
      writer.uint32(58).string(message.depositor);
    }

    if (message.funds !== undefined) {
      _coin.DecCoin.encode(message.funds, writer.uint32(66).fork()).ldelim();
    }

    return writer;
  },
  decode: function decode(input, length) {
    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    var end = length === undefined ? reader.len : reader.pos + length;
    var message = createBaseAccount();

    while (reader.pos < end) {
      var tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.id = AccountID.decode(reader, reader.uint32());
          break;

        case 2:
          message.owner = reader.string();
          break;

        case 3:
          message.state = reader.int32();
          break;

        case 4:
          message.balance = _coin.DecCoin.decode(reader, reader.uint32());
          break;

        case 5:
          message.transferred = _coin.DecCoin.decode(reader, reader.uint32());
          break;

        case 6:
          message.settledAt = reader.int64();
          break;

        case 7:
          message.depositor = reader.string();
          break;

        case 8:
          message.funds = _coin.DecCoin.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },
  fromJSON: function fromJSON(object) {
    return {
      id: (0, _helpers.isSet)(object.id) ? AccountID.fromJSON(object.id) : undefined,
      owner: (0, _helpers.isSet)(object.owner) ? String(object.owner) : "",
      state: (0, _helpers.isSet)(object.state) ? account_StateFromJSON(object.state) : 0,
      balance: (0, _helpers.isSet)(object.balance) ? _coin.DecCoin.fromJSON(object.balance) : undefined,
      transferred: (0, _helpers.isSet)(object.transferred) ? _coin.DecCoin.fromJSON(object.transferred) : undefined,
      settledAt: (0, _helpers.isSet)(object.settledAt) ? _helpers.Long.fromString(object.settledAt) : _helpers.Long.ZERO,
      depositor: (0, _helpers.isSet)(object.depositor) ? String(object.depositor) : "",
      funds: (0, _helpers.isSet)(object.funds) ? _coin.DecCoin.fromJSON(object.funds) : undefined
    };
  },
  toJSON: function toJSON(message) {
    var obj = {};
    message.id !== undefined && (obj.id = message.id ? AccountID.toJSON(message.id) : undefined);
    message.owner !== undefined && (obj.owner = message.owner);
    message.state !== undefined && (obj.state = account_StateToJSON(message.state));
    message.balance !== undefined && (obj.balance = message.balance ? _coin.DecCoin.toJSON(message.balance) : undefined);
    message.transferred !== undefined && (obj.transferred = message.transferred ? _coin.DecCoin.toJSON(message.transferred) : undefined);
    message.settledAt !== undefined && (obj.settledAt = (message.settledAt || _helpers.Long.ZERO).toString());
    message.depositor !== undefined && (obj.depositor = message.depositor);
    message.funds !== undefined && (obj.funds = message.funds ? _coin.DecCoin.toJSON(message.funds) : undefined);
    return obj;
  },
  fromPartial: function fromPartial(object) {
    var _object$owner, _object$state, _object$depositor;

    var message = createBaseAccount();
    message.id = object.id !== undefined && object.id !== null ? AccountID.fromPartial(object.id) : undefined;
    message.owner = (_object$owner = object.owner) !== null && _object$owner !== void 0 ? _object$owner : "";
    message.state = (_object$state = object.state) !== null && _object$state !== void 0 ? _object$state : 0;
    message.balance = object.balance !== undefined && object.balance !== null ? _coin.DecCoin.fromPartial(object.balance) : undefined;
    message.transferred = object.transferred !== undefined && object.transferred !== null ? _coin.DecCoin.fromPartial(object.transferred) : undefined;
    message.settledAt = object.settledAt !== undefined && object.settledAt !== null ? _helpers.Long.fromValue(object.settledAt) : _helpers.Long.ZERO;
    message.depositor = (_object$depositor = object.depositor) !== null && _object$depositor !== void 0 ? _object$depositor : "";
    message.funds = object.funds !== undefined && object.funds !== null ? _coin.DecCoin.fromPartial(object.funds) : undefined;
    return message;
  }
};
exports.Account = Account;

function createBaseFractionalPayment() {
  return {
    accountId: undefined,
    paymentId: "",
    owner: "",
    state: 0,
    rate: undefined,
    balance: undefined,
    withdrawn: undefined
  };
}

var FractionalPayment = {
  encode: function encode(message) {
    var writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _m0.Writer.create();

    if (message.accountId !== undefined) {
      AccountID.encode(message.accountId, writer.uint32(10).fork()).ldelim();
    }

    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }

    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }

    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }

    if (message.rate !== undefined) {
      _coin.DecCoin.encode(message.rate, writer.uint32(42).fork()).ldelim();
    }

    if (message.balance !== undefined) {
      _coin.DecCoin.encode(message.balance, writer.uint32(50).fork()).ldelim();
    }

    if (message.withdrawn !== undefined) {
      _coin.Coin.encode(message.withdrawn, writer.uint32(58).fork()).ldelim();
    }

    return writer;
  },
  decode: function decode(input, length) {
    var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    var end = length === undefined ? reader.len : reader.pos + length;
    var message = createBaseFractionalPayment();

    while (reader.pos < end) {
      var tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.accountId = AccountID.decode(reader, reader.uint32());
          break;

        case 2:
          message.paymentId = reader.string();
          break;

        case 3:
          message.owner = reader.string();
          break;

        case 4:
          message.state = reader.int32();
          break;

        case 5:
          message.rate = _coin.DecCoin.decode(reader, reader.uint32());
          break;

        case 6:
          message.balance = _coin.DecCoin.decode(reader, reader.uint32());
          break;

        case 7:
          message.withdrawn = _coin.Coin.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },
  fromJSON: function fromJSON(object) {
    return {
      accountId: (0, _helpers.isSet)(object.accountId) ? AccountID.fromJSON(object.accountId) : undefined,
      paymentId: (0, _helpers.isSet)(object.paymentId) ? String(object.paymentId) : "",
      owner: (0, _helpers.isSet)(object.owner) ? String(object.owner) : "",
      state: (0, _helpers.isSet)(object.state) ? fractionalPayment_StateFromJSON(object.state) : 0,
      rate: (0, _helpers.isSet)(object.rate) ? _coin.DecCoin.fromJSON(object.rate) : undefined,
      balance: (0, _helpers.isSet)(object.balance) ? _coin.DecCoin.fromJSON(object.balance) : undefined,
      withdrawn: (0, _helpers.isSet)(object.withdrawn) ? _coin.Coin.fromJSON(object.withdrawn) : undefined
    };
  },
  toJSON: function toJSON(message) {
    var obj = {};
    message.accountId !== undefined && (obj.accountId = message.accountId ? AccountID.toJSON(message.accountId) : undefined);
    message.paymentId !== undefined && (obj.paymentId = message.paymentId);
    message.owner !== undefined && (obj.owner = message.owner);
    message.state !== undefined && (obj.state = fractionalPayment_StateToJSON(message.state));
    message.rate !== undefined && (obj.rate = message.rate ? _coin.DecCoin.toJSON(message.rate) : undefined);
    message.balance !== undefined && (obj.balance = message.balance ? _coin.DecCoin.toJSON(message.balance) : undefined);
    message.withdrawn !== undefined && (obj.withdrawn = message.withdrawn ? _coin.Coin.toJSON(message.withdrawn) : undefined);
    return obj;
  },
  fromPartial: function fromPartial(object) {
    var _object$paymentId, _object$owner2, _object$state2;

    var message = createBaseFractionalPayment();
    message.accountId = object.accountId !== undefined && object.accountId !== null ? AccountID.fromPartial(object.accountId) : undefined;
    message.paymentId = (_object$paymentId = object.paymentId) !== null && _object$paymentId !== void 0 ? _object$paymentId : "";
    message.owner = (_object$owner2 = object.owner) !== null && _object$owner2 !== void 0 ? _object$owner2 : "";
    message.state = (_object$state2 = object.state) !== null && _object$state2 !== void 0 ? _object$state2 : 0;
    message.rate = object.rate !== undefined && object.rate !== null ? _coin.DecCoin.fromPartial(object.rate) : undefined;
    message.balance = object.balance !== undefined && object.balance !== null ? _coin.DecCoin.fromPartial(object.balance) : undefined;
    message.withdrawn = object.withdrawn !== undefined && object.withdrawn !== null ? _coin.Coin.fromPartial(object.withdrawn) : undefined;
    return message;
  }
};
exports.FractionalPayment = FractionalPayment;